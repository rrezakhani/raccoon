<!DOCTYPE html><head><meta charset="UTF-8"><title>index.md|RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://hugary1995.github.io/raccoon/index.html" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../install/index.html">Install</a></li><li class="moose-mega-menu-trigger" data-target="fccb9a6b-7f8a-4e33-b27b-b266ddc36230"><a>Benchmarks<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../modules/index.html">Modules</a></li><li><a href="../index.html">Syntax</a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="3028eb19-52d8-4496-bb81-c53c2c80f7c2"><i class="material-icons">menu</i></a><ul class="sidenav" id="3028eb19-52d8-4496-bb81-c53c2c80f7c2"><li><a href="../../install/index.html">Install</a></li><li><a href="../../benchmarks.menu.html">Benchmarks</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../modules/index.html">Modules</a></li><li><a href="../index.html">Syntax</a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="moose-mega-menu-content" id="fccb9a6b-7f8a-4e33-b27b-b266ddc36230"><div class="moose-mega-menu-wrapper"><div class="row row"><div class="col s12 m6 l4"><h2 id="mode-i-crack-propagation"><a href="../../benchmarks/mode1.html">Mode I crack propagation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../media/mode1.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div><div class="col s12 m6 l4"><h2 id="mode-ii-crack-propagation"><a href="../../benchmarks/mode2.html">Mode II crack propagation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../media/mode2.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div><div class="col s12 m6 l4"><h2 id="soil-desiccation"><a href="../../benchmarks/mud.html">Soil desiccation <i class="material-icons moose-inline-icon">link</i></a></h2><img src="../../media/soil.gif" class="materialboxed moose-image" style="width:75%;float:left;padding-top:2.5%;"></img><p></p></div></div></div></div><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://hugary1995.github.io/raccoon/index.html" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">Materials</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="56630750-f8cd-47cb-b859-66a7ec7b2398" data-section-level="1" data-section-text="Materials System"><h1 id="materials-system">Materials System</h1><p>The material system is the primary mechanism for defining spatially varying properties. The system allows properties to be defined in a single object (a <code>Material</code>) and shared among the many other systems such as the <a href="../Kernels/index.html">Kernel</a> or <a href="../BCs/index.html">BoundaryCondition</a> systems. Material objects are designed to directly couple to solution variables as well as other materials and therefore allow for capturing the true nonlinear behavior of the equations.</p><p>The material system relies on a producer/consumer relationship: <code>Material</code> objects <strong>produce</strong> properties and other objects (including materials) <strong>consume</strong> these properties.</p><p>The properties are produced on demand, thus the computed values are always up to date. For example, a property that relies on a solution variable (e.g., thermal conductivity as function of temperature) will be computed with the current temperature during the solve iterations, so the properties are tightly coupled.</p><p>The material system supports the use of automatic differentiation for property calculations, as such there are two approaches for producing and consuming properties: with and without automatic differentiation. The following sections detail the producing and consuming properties using the two approaches. To further understand automatic differentiation, please refer to the <a href="../../automatic_differentiation/index.html">Automatic Differentiation</a> page for more information.</p><p>The proceeding sections briefly describe the different aspects of a <code>Material</code> object for producing and computing the properties as well as how other objects consume the properties. For an example of how a <code>Material</code> object is created and used please refer to syntax/Materials/index.md.</p><section class="scrollspy" id="67ab34d9-3e49-4818-ab9e-969e7852859d" data-section-level="2" data-section-text="Producing / Computing Properties"><h2 id="producing-computing-properties">Producing/Computing Properties</h2><p>Properties must be produced by a <code>Material</code> object by declaring the property with one of two methods:</p><ol class="browser-default" start="1"><li><p><code>declareProperty&lt;TYPE&gt;(&quot;property_name&quot;)</code> declares a property with a name &quot;property_name&quot; to be computed by the <code>Material</code> object. </p></li><li><p><code>declareADProperty&lt;TYPE&gt;</code> declares a property with a name &quot;property_name&quot; to be computed by the <code>Material</code> object that will include automatic differentiation.</p></li></ol><p>The <code>TYPE</code> is any valid C++ type such an <code>int</code> or <code>Real</code> or <code>std::vector&lt;Real&gt;</code>. The properties must then be computed within the <code>computeQpProperties</code> method defined within the object.</p><p>The property name is an arbitrary name of the property, this name should be set such that it corresponds to the value be computed (e.g., &quot;diffusivity&quot;). The name provided here is the same name that will be used for consuming the property. More information on names is provided in <a href="index.html#property-names">Property Names</a> section below.</p><p>For example, consider a simulation that requires a diffusivity term. In the <code>Material</code> object header a property is declared (in the C++ since) as follows.</p><pre class="moose-pre"><code class="language-cpp">  MaterialProperty&lt;Real&gt; &amp; _diffusivity;
</code></pre><a href="#8960c410-b58e-48ba-b4a5-b421d9f73791" class="modal-trigger">(moose/examples/ex08_materials/include/materials/ExampleMaterial.h)</a><div class="modal moose-modal" id="8960c410-b58e-48ba-b4a5-b421d9f73791"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/examples/ex08_materials/include/materials/ExampleMaterial.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Material.h&quot;
#include &quot;LinearInterpolation.h&quot;

class ExampleMaterial;

template &lt;&gt;
InputParameters validParams&lt;ExampleMaterial&gt;();

class ExampleMaterial : public Material
{
public:
  ExampleMaterial(const InputParameters &amp; parameters);

protected:
  virtual void computeQpProperties() override;

private:
  /// member variable to hold the computed diffusivity coefficient
  MaterialProperty&lt;Real&gt; &amp; _diffusivity;
  /// member variable to hold the computed convection velocity gradient term
  MaterialProperty&lt;RealGradient&gt; &amp; _convection_velocity;

  /// A place to store the coupled variable gradient for calculating the convection velocity
  /// property.
  const VariableGradient &amp; _diffusion_gradient;

  /// A helper object for performaing linear interpolations on tabulated data for calculating the
  /// diffusivity property.
  LinearInterpolation _piecewise_func;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>All properties will either be a <code>MaterialProperty&lt;TYPE&gt;</code> or <code>ADMaterialProperty&lt;TYPE&gt;</code> and must be a non-const reference. Again, the <code>TYPE</code> can be any C++ type. In this example, a scalar <code>Real</code> number is being used.</p><p>In the source file the reference is initialized in the initialization list using the aforementioned declare functions as follows. This declares the property (in the material property sense) to be computed.</p><pre class="moose-pre"><code class="language-cpp">    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),
</code></pre><a href="#66949a00-1e35-4f0f-a49b-a6509f6f4714" class="modal-trigger">(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</a><div class="modal moose-modal" id="66949a00-1e35-4f0f-a49b-a6509f6f4714"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/examples/ex08_materials/src/materials/ExampleMaterial.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleMaterial.h&quot;

registerMooseObject(&quot;ExampleApp&quot;, ExampleMaterial);

template &lt;&gt;
InputParameters
validParams&lt;ExampleMaterial&gt;()
{
  InputParameters params = validParams&lt;Material&gt;();

  // Allow users to specify vectors defining the points of a piecewise function formed via linear
  // interpolation.
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;independent_vals&quot;,
      &quot;The vector of z-coordinate values for a piecewise function&#x27;s independent variable&quot;);
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;dependent_vals&quot;, &quot;The vector of diffusivity values for a piecewise function&#x27;s dependent&quot;);

  // Allow the user to specify which independent variable&#x27;s gradient to use for calculating the
  // convection velocity property:
  params.addCoupledVar(
      &quot;diffusion_gradient&quot;,
      &quot;The gradient of this variable will be used to compute a velocity vector property.&quot;);

  return params;
}

ExampleMaterial::ExampleMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    // Declare that this material is going to provide a Real value typed
    // material property named &quot;diffusivity&quot; that Kernels and other objects can use.
    // This property is &quot;bound&quot; to the class&#x27;s &quot;_diffusivity&quot; member.
    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),

    // Also declare a second &quot;convection_velocity&quot; RealGradient value typed property.
    _convection_velocity(declareProperty&lt;RealGradient&gt;(&quot;convection_velocity&quot;)),

    // Get the reference to the variable coupled into this Material.
    _diffusion_gradient(isCoupled(&quot;diffusion_gradient&quot;) ? coupledGradient(&quot;diffusion_gradient&quot;)
                                                        : _grad_zero),

    // Initialize our piecewise function helper with the user-specified interpolation points.
    _piecewise_func(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;independent_vals&quot;),
                    getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;dependent_vals&quot;))
{
}

void
ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>The final step for producing a property is to compute the value. The computation occurs within a <code>Material</code> object <code>computeQpProperties</code> method. As the method name suggests, the purpose of the method is to compute the values of properties at a quadrature point. This method is a virtual method that must be overridden. To do this, in the header the virtual method is declared (again in the C++ sense).</p><pre class="moose-pre"><code class="language-cpp">  virtual void computeQpProperties() override;
</code></pre><a href="#efe6b611-e5e5-4879-b6c1-fdb0b426e06b" class="modal-trigger">(moose/examples/ex08_materials/include/materials/ExampleMaterial.h)</a><div class="modal moose-modal" id="efe6b611-e5e5-4879-b6c1-fdb0b426e06b"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/examples/ex08_materials/include/materials/ExampleMaterial.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Material.h&quot;
#include &quot;LinearInterpolation.h&quot;

class ExampleMaterial;

template &lt;&gt;
InputParameters validParams&lt;ExampleMaterial&gt;();

class ExampleMaterial : public Material
{
public:
  ExampleMaterial(const InputParameters &amp; parameters);

protected:
  virtual void computeQpProperties() override;

private:
  /// member variable to hold the computed diffusivity coefficient
  MaterialProperty&lt;Real&gt; &amp; _diffusivity;
  /// member variable to hold the computed convection velocity gradient term
  MaterialProperty&lt;RealGradient&gt; &amp; _convection_velocity;

  /// A place to store the coupled variable gradient for calculating the convection velocity
  /// property.
  const VariableGradient &amp; _diffusion_gradient;

  /// A helper object for performaing linear interpolations on tabulated data for calculating the
  /// diffusivity property.
  LinearInterpolation _piecewise_func;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>In the source file the method is defined. For the current example this definition computes the &quot;diffusivity&quot; as well another term, refer to syntax/Materials/index.md.</p><pre class="moose-pre"><code class="language-cpp">ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre><a href="#bb13ab47-4967-467d-9e46-1e271098e37a" class="modal-trigger">(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</a><div class="modal moose-modal" id="bb13ab47-4967-467d-9e46-1e271098e37a"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/examples/ex08_materials/src/materials/ExampleMaterial.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleMaterial.h&quot;

registerMooseObject(&quot;ExampleApp&quot;, ExampleMaterial);

template &lt;&gt;
InputParameters
validParams&lt;ExampleMaterial&gt;()
{
  InputParameters params = validParams&lt;Material&gt;();

  // Allow users to specify vectors defining the points of a piecewise function formed via linear
  // interpolation.
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;independent_vals&quot;,
      &quot;The vector of z-coordinate values for a piecewise function&#x27;s independent variable&quot;);
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;dependent_vals&quot;, &quot;The vector of diffusivity values for a piecewise function&#x27;s dependent&quot;);

  // Allow the user to specify which independent variable&#x27;s gradient to use for calculating the
  // convection velocity property:
  params.addCoupledVar(
      &quot;diffusion_gradient&quot;,
      &quot;The gradient of this variable will be used to compute a velocity vector property.&quot;);

  return params;
}

ExampleMaterial::ExampleMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    // Declare that this material is going to provide a Real value typed
    // material property named &quot;diffusivity&quot; that Kernels and other objects can use.
    // This property is &quot;bound&quot; to the class&#x27;s &quot;_diffusivity&quot; member.
    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),

    // Also declare a second &quot;convection_velocity&quot; RealGradient value typed property.
    _convection_velocity(declareProperty&lt;RealGradient&gt;(&quot;convection_velocity&quot;)),

    // Get the reference to the variable coupled into this Material.
    _diffusion_gradient(isCoupled(&quot;diffusion_gradient&quot;) ? coupledGradient(&quot;diffusion_gradient&quot;)
                                                        : _grad_zero),

    // Initialize our piecewise function helper with the user-specified interpolation points.
    _piecewise_func(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;independent_vals&quot;),
                    getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;dependent_vals&quot;))
{
}

void
ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>The purpose of the content of this method is to assign values for the properties at a quadrature point. Recall that &quot;_diffusivity&quot; is a reference to a <code>MaterialProperty</code> type. The <code>MaterialProperty</code> type is a container that stores the values of a property for each quadrature point. Therefore, this container must be indexed by <code>_qp</code> to compute the value for a specific quadrature point.</p></section><section class="scrollspy" id="e3fbaf2c-fe4e-4e61-b1c3-16f4ddf8c0e0" data-section-level="2" data-section-text="Consuming Properties"><h2 id="consuming-properties">Consuming Properties</h2><p>Objects that require material properties consume them using one of two functions</p><ol class="browser-default" start="1"><li><p><code>getMaterialProperty&lt;TYPE&gt;(&quot;property_name&quot;)</code> retrieves a property with a name &quot;property_name&quot; to be consumed by the object. </p></li><li><p><code>getADMaterialProperty&lt;TYPE&gt;</code> retrieves a property with a name &quot;property_name&quot; to be consumed by the object that will include automatic differentiation.</p></li></ol><p>For on object to consume a property the same basic procedure is followed. First in the consuming objects header file a <code>MaterialProperty</code> with the correct type (e.g., <code>Real</code> for the diffusivity example) is declared (in the C++ sense) as follows. Notice, that the member variable is a <strong>const</strong> reference. The const is important. Consuming objects cannot modify a property, it only uses the property so it is marked to be constant.</p><pre class="moose-pre"><code class="language-cpp">  const MaterialProperty&lt;Real&gt; &amp; _diffusivity;
</code></pre><a href="#99b9160f-8add-4b1a-8a83-5a510af6c88a" class="modal-trigger">(moose/examples/ex08_materials/include/kernels/ExampleDiffusion.h)</a><div class="modal moose-modal" id="99b9160f-8add-4b1a-8a83-5a510af6c88a"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/examples/ex08_materials/include/kernels/ExampleDiffusion.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Diffusion.h&quot;

// Forward Declarations
class ExampleDiffusion;

/**
 * validParams returns the parameters that this Kernel accepts / needs
 * The actual body of the function MUST be in the .C file.
 */
template &lt;&gt;
InputParameters validParams&lt;ExampleDiffusion&gt;();

class ExampleDiffusion : public Diffusion
{
public:
  ExampleDiffusion(const InputParameters &amp; parameters);

protected:
  virtual Real computeQpResidual() override;
  virtual Real computeQpJacobian() override;

  /**
   * This MooseArray will hold the reference we need to our
   * material property from the Material class
   */
  const MaterialProperty&lt;Real&gt; &amp; _diffusivity;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>In the source file the reference is initialized in the initialization list using the aforementioned get methods. This method initializes the <code>_diffusivity</code> member variable to reference the desired value of the property as computed by the material object.</p><pre class="moose-pre"><code class="language-cpp">  : Diffusion(parameters), _diffusivity(getMaterialProperty&lt;Real&gt;(&quot;diffusivity&quot;))
</code></pre><a href="#f5e9930d-386c-48ac-b94d-11d91c8e1228" class="modal-trigger">(moose/examples/ex08_materials/src/kernels/ExampleDiffusion.C)</a><div class="modal moose-modal" id="f5e9930d-386c-48ac-b94d-11d91c8e1228"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/examples/ex08_materials/src/kernels/ExampleDiffusion.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleDiffusion.h&quot;

/**
 * This function defines the valid parameters for
 * this Kernel and their default values
 */
registerMooseObject(&quot;ExampleApp&quot;, ExampleDiffusion);

template &lt;&gt;
InputParameters
validParams&lt;ExampleDiffusion&gt;()
{
  InputParameters params = validParams&lt;Diffusion&gt;();
  return params;
}

ExampleDiffusion::ExampleDiffusion(const InputParameters &amp; parameters)
  : Diffusion(parameters), _diffusivity(getMaterialProperty&lt;Real&gt;(&quot;diffusivity&quot;))
{
}

Real
ExampleDiffusion::computeQpResidual()
{
  // Reusing the Diffusion Kernel&#x27;s residual calculation
  return _diffusivity[_qp] * Diffusion::computeQpResidual();
}

Real
ExampleDiffusion::computeQpJacobian()
{
  // Reusing the Diffusion Kernel&#x27;s jacobian calculation
  return _diffusivity[_qp] * Diffusion::computeQpJacobian();
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>The name used in the get method, &quot;diffusivity&quot;, in this case is not arbitrary. This name corresponds with the name used to declare the property in the material object.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><span class="moose-alert-title-brand">note:</span>The declare/get calls must correspond</div><div class="card-content"><div class="moose-alert-content"><p><p>If a material property is declared for automatic differentiation (AD) using <code>declareADProperty</code> then it <strong>must</strong> be consumed with the <code>getADMaterialProperty</code>. The same is true for non-automatic differentiation; properties declared with <code>declareProperty</code> <strong>must</strong> be consumed with the <code>getMaterialProperty</code> method.</p></p></div></div></div></section><section class="scrollspy" id="08ed571d-cc8d-46cd-9016-57df9894006a" data-section-level="2" data-section-text="Property Names"><h2 id="property-names">Property Names</h2><p>When creating a Material object and declaring the properties that shall be computed, it is often desirable to allow for the property name to be changed via the input file. This may be accomplished by adding an input parameter for assigning the name. For example, considering the example above the following code snippet adds an input parameter, &quot;diffusivity_name&quot;, that allows the input file to set the name of the diffusivity property, but by default the name remains &quot;diffusivity&quot;.</p><pre class="moose-pre"><code class="language-c++">
params.addParam&lt;MaterialPropertyName&gt;(&quot;diffusivity_name&quot;, &quot;diffusivity&quot;,
                                      &quot;The name of the diffusivity material property.&quot;);
</code></pre><p>In the material object, the declare function is simply changed to use the parameter name rather than string by itself. By default a property will be declared with the name &quot;diffusivity&quot;.</p><pre class="moose-pre"><code class="language-cpp">    _diffusivity_name(declareProperty&lt;Real&gt;(&quot;diffusivity_name&quot;)),
</code></pre><a href="#ede8813d-511f-443d-b8ed-76ec174254c9" class="modal-trigger">(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</a><div class="modal moose-modal" id="ede8813d-511f-443d-b8ed-76ec174254c9"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/examples/ex08_materials/src/materials/ExampleMaterial.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleMaterial.h&quot;

registerMooseObject(&quot;ExampleApp&quot;, ExampleMaterial);

template &lt;&gt;
InputParameters
validParams&lt;ExampleMaterial&gt;()
{
  InputParameters params = validParams&lt;Material&gt;();

  // Allow users to specify vectors defining the points of a piecewise function formed via linear
  // interpolation.
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;independent_vals&quot;,
      &quot;The vector of z-coordinate values for a piecewise function&#x27;s independent variable&quot;);
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;dependent_vals&quot;, &quot;The vector of diffusivity values for a piecewise function&#x27;s dependent&quot;);

  // Allow the user to specify which independent variable&#x27;s gradient to use for calculating the
  // convection velocity property:
  params.addCoupledVar(
      &quot;diffusion_gradient&quot;,
      &quot;The gradient of this variable will be used to compute a velocity vector property.&quot;);

  return params;
}

ExampleMaterial::ExampleMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    // Declare that this material is going to provide a Real value typed
    // material property named &quot;diffusivity&quot; that Kernels and other objects can use.
    // This property is &quot;bound&quot; to the class&#x27;s &quot;_diffusivity&quot; member.
    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),

    // Also declare a second &quot;convection_velocity&quot; RealGradient value typed property.
    _convection_velocity(declareProperty&lt;RealGradient&gt;(&quot;convection_velocity&quot;)),

    // Get the reference to the variable coupled into this Material.
    _diffusion_gradient(isCoupled(&quot;diffusion_gradient&quot;) ? coupledGradient(&quot;diffusion_gradient&quot;)
                                                        : _grad_zero),

    // Initialize our piecewise function helper with the user-specified interpolation points.
    _piecewise_func(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;independent_vals&quot;),
                    getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;dependent_vals&quot;))
{
}

void
ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>However, if the user wants to alter this name to something else, such as &quot;not_diffusivity&quot; then the input parameter &quot;diffusivity_name&quot; is simply added to the input file block for the material.</p><pre class="moose-pre"><code class="language-text">
[Materials]
  [example]
    type = ExampleMaterial
    diffusivity_name = not_diffusivity
  []
[]
</code></pre><p>On the consumer side, the get method will now be required to use the name &quot;not_diffusivity&quot; to retrieve the property. Consuming objects can also use the same procedure to allow for custom property names by adding a parameter and using the parameter name in the get method in the same fashion.</p></section><section class="scrollspy" id="1fe7e094-bf57-4255-86a2-c74b3713612c" data-section-level="2" data-section-text="Default Material Properties"><h2 id="default-material-properties">Default Material Properties</h2><p>The <a href="index.html#material-name" class="moose-error">index.html#material-name</a> input parameter also provides the ability to set default values for scalar (<code>Real</code>) properties. In the above example, the input file can use number or parsed function (see <a href="../../source/functions/MooseParsedFunction.html">ParsedFunction</a>) to define a the property value. For example, the input snippet above could set a constant value.</p><pre class="moose-pre"><code class="language-text">
[Materials]
  [example]
    type = ExampleMaterial
    diffusivity_name = 12345
  []
[]
</code></pre></section><section class="scrollspy" id="3a356c8d-1523-497e-a293-8cca379fd8bd" data-section-level="2" data-section-text="Stateful Material Properties"><h2 id="stateful-material-properties">Stateful Material Properties</h2><p>In general properties are computed on demand and not stored. However, in some cases values of material properties from a previous timestep may be required. To access properties two methods exist:</p><ul class="browser-default"><li><p><code>getMaterialPropertyOld&lt;TYPE&gt;</code> returns a reference to the property from the previous timestep. </p></li><li><p><code>getMaterialPropertyOlder&lt;TYPE&gt;</code> returns a reference to the property from two timesteps before the current.</p></li></ul><p>This is often referred to as a &quot;state&quot; variable, in MOOSE we refer to them as &quot;stateful material properties.&quot; As stated, material properties are usually computed on demand.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><span class="moose-alert-title-brand">warning:</span>Stateful properties will increase memory use</div><div class="card-content"><div class="moose-alert-content"><p><p>When a stateful property is requested through one of the above methods this is no longer the case. When it is computed the value is also stored for every quadrature point on every element. As such, stateful properties can become memory intensive, especially if the property being stored is a vector or tensor value.</p></p></div></div></div></section><section class="scrollspy" id="a01f7707-3d52-4072-9e28-326c48ee89d8" data-section-level="2" data-section-text="Material Property Output"><h2 id="material-property-output">Material Property Output</h2><p>Output of <code>Material</code> properties is enabled by setting the &quot;outputs&quot; parameter. The following example creates two additional variables called &quot;mat1&quot; and &quot;mat2&quot; that will show up in the output file.</p><pre class="moose-pre"><code class="language-text">[Materials]
  [block_1]
    type = OutputTestMaterial
    block = 1
    output_properties = &#x27;real_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
  [block_2]
    type = OutputTestMaterial
    block = 2
    output_properties = &#x27;vector_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
[]

[Outputs]
  exodus = true
[]
</code></pre><a href="#b1c5ff4e-0c64-4db5-ad9f-72af33141017" class="modal-trigger">(moose/test/tests/materials/output/output_block.i)</a><div class="modal moose-modal" id="b1c5ff4e-0c64-4db5-ad9f-72af33141017"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/test/tests/materials/output/output_block.i</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = rectangle.e
  dim = 2
  uniform_refine = 1
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diff]
    type = CoefDiffusion
    variable = u
    coef = 0.5
  []
  [time]
    type = TimeDerivative
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 2
  []
[]

[Materials]
  [block_1]
    type = OutputTestMaterial
    block = 1
    output_properties = &#x27;real_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
  [block_2]
    type = OutputTestMaterial
    block = 2
    output_properties = &#x27;vector_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p><code>Material</code> properties can be of arbitrary (C++) type, but not all types can be output. The following table lists the types of properties that are available for automatic output.</p><div form="['left', 'left', 'left']" recursive="True" class="moose-table-div"><table><thead><tr><th style=";text-align:left">Type</th><th style=";text-align:left">AuxKernel</th><th style=";text-align:left">Variable Name(s)</th></tr></thead><tbody><tr><td style=";text-align:left">Real</td><td style=";text-align:left"><code>MaterialRealAux</code></td><td style=";text-align:left">prop</td></tr></tbody><tbody><tr><td style=";text-align:left">RealVectorValue</td><td style=";text-align:left"><code>MaterialRealVectorValueAux</code></td><td style=";text-align:left">prop_1, prop_2, and prop_3</td></tr></tbody><tbody><tr><td style=";text-align:left">RealTensorValue</td><td style=";text-align:left"><code>MaterialRealTensorValueAux</code></td><td style=";text-align:left">prop_11, prop_12, prop_13, prop_21, etc.</td></tr></tbody></table></div></section><section class="scrollspy" id="73acb856-e794-4fa3-bd5b-f58e3c70993e" data-section-level="2" data-section-text="Advanced Topics"><h2 id="advanced-topics">Advanced Topics</h2><section id="81037339-f924-4f03-9e59-aa601c217b3b" data-section-level="3" data-section-text="Discrete Material Objects"><h3 id="discrete-material-objects">Discrete Material Objects</h3><p>A &quot;<a href="http://www.dictionary.com/browse/discrete">Discrete</a>&quot; <code>Material</code> is an object that may be detached from MOOSE and computed explicitly from other objects. An object inheriting from <a href="http://www.mooseframework.org/docs/doxygen/moose/classMaterialPropertyInterface.html">MaterialPropertyInterface</a> may explicitly call the compute methods of a <code>Material</code> object via the <code>getMaterial</code> method.</p><p>The following should be considered when computing <code>Material</code> properties explicitly.</p><ul class="browser-default"><li><p>It is possible to disable the automatic computation of a <code>Material</code> object by MOOSE by setting the <code>compute=false</code> parameter. </p></li><li><p>When <code>compute=false</code> is set the compute method (<code>computeQpProperties</code>) is <strong>not</strong> called by MOOSE, instead it must be called explicitly in your application using the <code>computeProperties</code> method that accepts a quadrature point index. </p></li><li><p>When <code>compute=false</code> an additional method should be defined, <code>resetQpProperties</code>, which sets the properties to a safe value (e.g., 0) for later calls to the compute method. Not doing this can lead to erroneous material properties values.</p></li></ul><p>The original intent for this functionality was to enable to ability for material properties to be computed via iteration by another object, as in the following example. First, consider define a material (<code>RecomputeMaterial</code>) that computes the value of a function and its derivative.</p><span class="moose-katex-block-equation"><span tex="f(p) = p^2v" bookmark="moose-equation-36c42227-11ad-4c58-9f4d-fcd4d6013190" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-36c42227-11ad-4c58-9f4d-fcd4d6013190"></span><script>var element = document.getElementById("moose-equation-36c42227-11ad-4c58-9f4d-fcd4d6013190");katex.render("f(p) = p^2v", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span><p>and</p><span class="moose-katex-block-equation"><span tex="f'(p) = 2pv," bookmark="moose-equation-833d6d50-9c15-424a-bda2-eaf123274472" recursive="True" class="moose-katex-equation table-cell" id="moose-equation-833d6d50-9c15-424a-bda2-eaf123274472"></span><script>var element = document.getElementById("moose-equation-833d6d50-9c15-424a-bda2-eaf123274472");katex.render("f'(p) = 2pv,", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span><p>where v is known value and not a function of p. The following is the compute portion of this object.</p><pre class="moose-pre"><code class="language-cpp">void
RecomputeMaterial::computeQpProperties()
{
  Real x = _p[_qp];
  _f[_qp] = x * x - _constant;
  _f_prime[_qp] = 2 * x;
}
</code></pre><a href="#b34e407c-9b05-4417-bb0f-3b37f62a2ae6" class="modal-trigger">(moose/test/src/materials/RecomputeMaterial.C)</a><div class="modal moose-modal" id="b34e407c-9b05-4417-bb0f-3b37f62a2ae6"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/test/src/materials/RecomputeMaterial.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;RecomputeMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, RecomputeMaterial);

InputParameters
RecomputeMaterial::validParams()
{
  InputParameters params = Material::validParams();
  params.addRequiredParam&lt;std::string&gt;(&quot;f_name&quot;,
                                       &quot;The name of the property that holds the value to &quot;
                                       &quot;of the function for which the root is being &quot;
                                       &quot;computed&quot;);
  params.addRequiredParam&lt;std::string&gt;(
      &quot;f_prime_name&quot;,
      &quot;The name of the property that holds the value to of the derivative of the function&quot;);
  params.addRequiredParam&lt;std::string&gt;(&quot;p_name&quot;,
                                       &quot;The name of the independant variable for the function&quot;);
  params.addParam&lt;Real&gt;(&quot;constant&quot;, 0, &quot;The constant to add to the f equation.&quot;);
  return params;
}

RecomputeMaterial::RecomputeMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    _f(declareProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_name&quot;))),
    _f_prime(declareProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_prime_name&quot;))),
    _p(getMaterialProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;p_name&quot;))),
    _constant(getParam&lt;Real&gt;(&quot;constant&quot;))
{
}

void
RecomputeMaterial::resetQpProperties()
{
  _f[_qp] = 84;
  _f_prime[_qp] = 42;
}

// MOOSEDOCS_START
void
RecomputeMaterial::computeQpProperties()
{
  Real x = _p[_qp];
  _f[_qp] = x * x - _constant;
  _f_prime[_qp] = 2 * x;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>Second, define another material (<code>NewtonMaterial</code>) that computes the value of <span tex="p: f(p)=0" bookmark="moose-equation-69250737-d9a6-4ed5-8613-efe12ea272ec" recursive="True" class="moose-katex-inline-equation" id="moose-equation-69250737-d9a6-4ed5-8613-efe12ea272ec"><script>var element = document.getElementById("moose-equation-69250737-d9a6-4ed5-8613-efe12ea272ec");katex.render("p: f(p)=0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span> using Newton iterations. This material declares a material property (<code>_p</code>) which is what is solved for by iterating on the material properties containing <code>f</code> and <code>f&#x27;</code> from <code>RecomputeMaterial</code>. The <code>_discrete</code> member is a reference to a <code>Material</code> object retrieved with <code>getMaterial</code>.</p><pre class="moose-pre"><code class="language-cpp">// MOOSEDOCS_START
void
NewtonMaterial::computeQpProperties()
{
  _p[_qp] = 0.5; // initial guess

  // Newton iteration for find p
  for (unsigned int i = 0; i &lt; _max_iterations; ++i)
  {
    _discrete.computePropertiesAtQp(_qp);
    _p[_qp] -= _f[_qp] / _f_prime[_qp];
    if (std::abs(_f[_qp]) &lt; _tol)
      break;
  }
}
</code></pre><a href="#71886809-d93f-42f8-850b-2e30d545232a" class="modal-trigger">(moose/test/src/materials/NewtonMaterial.C)</a><div class="modal moose-modal" id="71886809-d93f-42f8-850b-2e30d545232a"><div class="modal-content"><h4>/home/travis/build/hugary1995/raccoon/moose/test/src/materials/NewtonMaterial.C</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;NewtonMaterial.h&quot;
#include &quot;Material.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, NewtonMaterial);

InputParameters
NewtonMaterial::validParams()
{
  InputParameters params = Material::validParams();
  params.addRequiredParam&lt;std::string&gt;(&quot;f_name&quot;,
                                       &quot;The name of the property that holds the value of &quot;
                                       &quot;the function for which the root is being &quot;
                                       &quot;computed&quot;);
  params.addRequiredParam&lt;std::string&gt;(
      &quot;f_prime_name&quot;,
      &quot;The name of the property that holds the value to of the derivative of the function&quot;);
  params.addRequiredParam&lt;std::string&gt;(&quot;p_name&quot;,
                                       &quot;The name of the independent variable for the function&quot;);
  params.addParam&lt;Real&gt;(&quot;tol&quot;, 1e-12, &quot;Newton solution tolerance.&quot;);
  params.addParam&lt;unsigned int&gt;(&quot;max_iterations&quot;, 42, &quot;The maximum number of Newton iterations.&quot;);
  params.addRequiredParam&lt;MaterialName&gt;(&quot;material&quot;, &quot;The material object to recompute.&quot;);
  return params;
}

NewtonMaterial::NewtonMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    _tol(getParam&lt;Real&gt;(&quot;tol&quot;)),
    _f(getMaterialProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_name&quot;))),
    _f_prime(getMaterialProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_prime_name&quot;))),
    _p(declareProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;p_name&quot;))),
    _max_iterations(getParam&lt;unsigned int&gt;(&quot;max_iterations&quot;)),
    _discrete(getMaterial(&quot;material&quot;))
{
}

// MOOSEDOCS_START
void
NewtonMaterial::computeQpProperties()
{
  _p[_qp] = 0.5; // initial guess

  // Newton iteration for find p
  for (unsigned int i = 0; i &lt; _max_iterations; ++i)
  {
    _discrete.computePropertiesAtQp(_qp);
    _p[_qp] -= _f[_qp] / _f_prime[_qp];
    if (std::abs(_f[_qp]) &lt; _tol)
      break;
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><p>To create and use a &quot;Discrete&quot; <code>Material</code> use the following to guide the process.</p><ol class="browser-default" start="1"><li><p>Create a <code>Material</code> object by, in typical MOOSE fashion, inheriting from the <code>Material</code> object in your own application. </p></li><li><p>In your input file, set <code>compute=false</code> for this new object. </p></li><li><p>From within another object (e.g., another Material) that inherits from <code>MaterialPropertyInterface</code> call the <code>getMaterial</code> method. Note, this method returns a reference to a <code>Material</code> object, be sure to include <code>&amp;</code> when calling or declaring the variable. </p></li><li><p>When needed, call the <code>computeProperties</code> method of the <code>Material</code> being sure to provide the current quadrature point index to the method (<code>_qp</code> in most cases).</p></li></ol></section></section><section class="scrollspy" id="f4ece308-4849-49c0-b404-54d8421ffb87" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/materials/GenericConstantMaterial.html">ADGenericConstantMaterial</a></li><li class="collection-item"><a href="../../source/materials/GenericFunctionMaterial.html">ADGenericFunctionMaterial</a></li><li class="collection-item"><a href="../../source/materials/ADPiecewiseLinearInterpolationMaterial.html">ADPiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="../../source/materials/DerivativeParsedMaterial.html">DerivativeParsedMaterial</a>Parsed Function Material with automatic derivatives.</li><li class="collection-item"><a href="../../source/materials/DerivativeSumMaterial.html">DerivativeSumMaterial</a>Meta-material to sum up multiple derivative materials</li><li class="collection-item"><a href="../../source/materials/GenericConstant2DArray.html">GenericConstant2DArray</a>A material evaluating one material property in type of RealEigenMatrix</li><li class="collection-item"><a href="../../source/materials/GenericConstantArray.html">GenericConstantArray</a>A material evaluating one material property in type of RealEigenVector</li><li class="collection-item"><a href="../../source/materials/GenericConstantMaterial.html">GenericConstantMaterial</a></li><li class="collection-item"><a href="../../source/materials/GenericConstantRankTwoTensor.html">GenericConstantRankTwoTensor</a></li><li class="collection-item"><a href="../../source/materials/GenericFunctionMaterial.html">GenericFunctionMaterial</a></li><li class="collection-item"><a href="../../source/materials/MaterialConverter.html">MaterialConverter</a>Converts regular material properties to AD properties and visa versa</li><li class="collection-item"><a href="../../source/materials/ParsedMaterial.html">ParsedMaterial</a>Parsed Function Material.</li><li class="collection-item"><a href="../../source/materials/PiecewiseLinearInterpolationMaterial.html">PiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="../../source/materials/MaterialConverter.html">RankFourTensorMaterialConverter</a>Converts regular material properties to AD properties and visa versa</li><li class="collection-item"><a href="../../source/materials/MaterialConverter.html">RankTwoTensorMaterialConverter</a>Converts regular material properties to AD properties and visa versa</li><li class="collection-header">raccoon App</li><li class="collection-item"><a href="../../source/materials/ComputeEigenstrainFromFunctionEigenstress.html">ADComputeEigenstrainFromFunctionEigenstress</a>Computes an eigenstrain from an eigen stress</li><li class="collection-item"><a href="../../source/materials/SumRankTwoMaterial.html">ADSumRankTwoMaterial</a>sum a list of Rank Two Tensor materials</li><li class="collection-item"><a href="../../source/materials/SumRealMaterial.html">ADSumRealMaterial</a>sum a list of Real materials</li><li class="collection-item"><a href="../../source/materials/CNHDegradedElasticPlasticPK1Stress_LinearHardening.html">CNHDegradedElasticPlasticPK1Stress_LinearHardening</a>defines a linear hardening law</li><li class="collection-item"><a href="../../source/materials/CNHDegradedElasticPlasticPK1Stress_LinearHardening_Coalescence.html">CNHDegradedElasticPlasticPK1Stress_LinearHardening_Coalescence</a>defines a linear hardening law</li><li class="collection-item"><a href="../../source/materials/CNHDegradedElasticPlasticPK1Stress_LinearHardening_StrictlyDissipative.html">CNHDegradedElasticPlasticPK1Stress_LinearHardening_StrictlyDissipative</a>defines a linear hardening law</li><li class="collection-item"><a href="../../source/materials/CNHElasticPK1Stress.html">CNHElasticPK1Stress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="../../source/materials/CoalescenceEnergy.html">CoalescenceEnergy</a>computes coalescence mobility of the form <span tex="g^p(d) c M e^p w(d)" bookmark="moose-equation-2f714ee9-7298-4429-b9ef-28c8dce511f6" recursive="True" class="moose-katex-inline-equation" id="moose-equation-2f714ee9-7298-4429-b9ef-28c8dce511f6"><script>var element = document.getElementById("moose-equation-2f714ee9-7298-4429-b9ef-28c8dce511f6");katex.render("g^p(d) c M e^p w(d)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span></li><li class="collection-item"><a href="../../source/materials/ComputeEigenstrainFromFunctionEigenstress.html">ComputeEigenstrainFromFunctionEigenstress</a>Computes an eigenstrain from an eigen stress</li><li class="collection-item"><a href="../../source/materials/ComputeEigenstrainFromScalarInitialStress.html">ComputeEigenstrainFromScalarInitialStress</a>Computes an eigenstrain from an initial stress</li><li class="collection-item"><a href="../../source/materials/CrackSurfaceDensity.html">CrackSurfaceDensity</a>computes the crack surface density as a function of damage</li><li class="collection-item"><a href="../../source/materials/CriticalFractureEnergy.html">CriticalFractureEnergy</a>Compute the critical fracture energy given degradation function, local disiipation and mobility</li><li class="collection-item"><a href="../../source/materials/ElasticEnergyDensity.html">ElasticEnergyDensity</a>computes the elastic energy density <span tex="\frac{1}{2} \stress : \strain" bookmark="moose-equation-2d88c48a-a02c-4f0c-b525-2ebe6358db28" recursive="True" class="moose-katex-inline-equation" id="moose-equation-2d88c48a-a02c-4f0c-b525-2ebe6358db28"><script>var element = document.getElementById("moose-equation-2d88c48a-a02c-4f0c-b525-2ebe6358db28");katex.render("\\frac{1}{2} \\stress : \\strain", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span></li><li class="collection-item"><a href="../../source/materials/FractureMaterial.html">FractureMaterial</a>Compute interface coefficient kappa and mobility for a damage field based on provided energy release rate Gc and crack length scale L</li><li class="collection-item"><a href="../../source/materials/GreenStrain.html">GreenStrain</a>Compute Green strain in RZ coordinate.</li><li class="collection-item"><a href="../../source/materials/GreenStrainRZ.html">GreenStrainRZ</a>Compute Green strain in RZ coordinate.</li><li class="collection-item"><a href="../../source/materials/IncompressibilityPenaltyElasticPK1Stress.html">IncompressibilityPenaltyElasticPK1Stress</a>Compute stress to penalize volume change</li><li class="collection-item"><a href="../../source/materials/LCGStrain.html">LCGStrain</a>Compute the left Cauchy-Green strain.</li><li class="collection-item"><a href="../../source/materials/LinearDegradation.html">LinearDegradation</a>computes the degradation function of quadratic form, <span tex="(1 - d)" bookmark="moose-equation-a015bdf8-23bd-49a4-a695-01e5ada94574" recursive="True" class="moose-katex-inline-equation" id="moose-equation-a015bdf8-23bd-49a4-a695-01e5ada94574"><script>var element = document.getElementById("moose-equation-a015bdf8-23bd-49a4-a695-01e5ada94574");katex.render("(1 - d)", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span>.</li><li class="collection-item"><a href="../../source/materials/LinearLocalDissipation.html">LinearLocalDissipation</a>computes the local dissipation function of the linear form, <span tex="d" bookmark="moose-equation-3c0ba16f-dc86-4810-948d-0e21cd0ceeb6" recursive="True" class="moose-katex-inline-equation" id="moose-equation-3c0ba16f-dc86-4810-948d-0e21cd0ceeb6"><script>var element = document.getElementById("moose-equation-3c0ba16f-dc86-4810-948d-0e21cd0ceeb6");katex.render("d", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span></li><li class="collection-item"><a href="../../source/materials/LorentzDegradation.html">LorentzDegradation</a>computes the Lorentz-type degradation: <span tex="\frac{(1-d)^2}{(1-d)^2+\frac{M}{\psi_\critical}d(1+pd)}" bookmark="moose-equation-742168dc-dba5-4f4e-8ef1-95bc52fdd4fe" recursive="True" class="moose-katex-inline-equation" id="moose-equation-742168dc-dba5-4f4e-8ef1-95bc52fdd4fe"><script>var element = document.getElementById("moose-equation-742168dc-dba5-4f4e-8ef1-95bc52fdd4fe");katex.render("\\frac{(1-d)^2}{(1-d)^2+\\frac{M}{\\psi_\\critical}d(1+pd)}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span></li><li class="collection-item"><a href="../../source/materials/MooneyRivlinElasticPK1Stress.html">MooneyRivlinElasticPK1Stress</a>Compute stress using the Mooney-Rivlin hyperelastic model</li><li class="collection-item"><a href="../../source/materials/Penetration.html">Penetration</a>computes the penetration density for a phase-field regularized crack.</li><li class="collection-item"><a href="../../source/materials/QuadraticDegradation.html">QuadraticDegradation</a>computes the degradation function of quadratic form, <span tex="(1 - d) ^ 2" bookmark="moose-equation-2163bb4a-8256-4968-9189-7160bd5adc8e" recursive="True" class="moose-katex-inline-equation" id="moose-equation-2163bb4a-8256-4968-9189-7160bd5adc8e"><script>var element = document.getElementById("moose-equation-2163bb4a-8256-4968-9189-7160bd5adc8e");katex.render("(1 - d) ^ 2", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span>.</li><li class="collection-item"><a href="../../source/materials/QuadraticLocalDissipation.html">QuadraticLocalDissipation</a>computes the local dissipation potential of the form <span tex="\xi d + (1 - \xi) d" bookmark="moose-equation-8978a9fa-62cd-4103-a1dd-0216290125f8" recursive="True" class="moose-katex-inline-equation" id="moose-equation-8978a9fa-62cd-4103-a1dd-0216290125f8"><script>var element = document.getElementById("moose-equation-8978a9fa-62cd-4103-a1dd-0216290125f8");katex.render("\\xi d + (1 - \\xi) d", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span>.</li><li class="collection-item"><a href="../../source/materials/QuasiLinearDegradation.html">QuasiLinearDegradation</a>computes the quasi-linear Lorentz-type degradation: <span tex="\frac{(1-d)}{(1-d)+\frac{M}{\psi_\critical}d}" bookmark="moose-equation-d643029d-8a18-4854-8124-2c9e5e8ca1e2" recursive="True" class="moose-katex-inline-equation" id="moose-equation-d643029d-8a18-4854-8124-2c9e5e8ca1e2"><script>var element = document.getElementById("moose-equation-d643029d-8a18-4854-8124-2c9e5e8ca1e2");katex.render("\\frac{(1-d)}{(1-d)+\\frac{M}{\\psi_\\critical}d}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span></li><li class="collection-item"><a href="../../source/materials/RCGStrain.html">RCGStrain</a>Compute the right Cauchy-Green strain</li><li class="collection-item"><a href="../../source/materials/SVKElasticPK1Stress.html">SVKElasticPK1Stress</a>Compute stress using the St. Venant Kirchhoff hyperelastic model</li><li class="collection-item"><a href="../../source/materials/SmallStrainDegradedElasticPK2Stress_NoSplit.html">SmallStrainDegradedElasticPK2Stress_NoSplit</a>Compute degraded stress following small deformation elasticity without active/inactive split</li><li class="collection-item"><a href="../../source/materials/SmallStrainDegradedElasticPK2Stress_StrainSpectral.html">SmallStrainDegradedElasticPK2Stress_StrainSpectral</a>Compute degraded stress following small deformation elasticity with a spectra-based active/inactive split</li><li class="collection-item"><a href="../../source/materials/SmallStrainDegradedElasticPK2Stress_StrainVolDev.html">SmallStrainDegradedElasticPK2Stress_StrainVolDev</a>Compute degraded stress following small deformation elasticity with a volumetric-deviatoric active/inactive split</li><li class="collection-item"><a href="../../source/functions/StationaryGenericFunctionMaterial.html">StationaryGenericFunctionMaterial</a>parses function material properties that are stationary in time. Computational cost is minimized by storing the stationary data but more memory is consumed in turn.</li><li class="collection-item"><a href="../../source/materials/SumRankTwoMaterial.html">SumRankTwoMaterial</a>sum a list of Rank Two Tensor materials</li><li class="collection-item"><a href="../../source/materials/SumRealMaterial.html">SumRealMaterial</a>sum a list of Real materials</li><li class="collection-item"><a href="../../source/materials/ThinFilmInterfaceEnergy.html">ThinFilmInterfaceEnergy</a>computes the interface energy corresponding to a shear-lag model, i.e. <span tex="\psi = 0.5 c \bs{u} \cdot \bs{u}" bookmark="moose-equation-89684e68-1d66-46cd-ad0b-92d32ccefbcd" recursive="True" class="moose-katex-inline-equation" id="moose-equation-89684e68-1d66-46cd-ad0b-92d32ccefbcd"><script>var element = document.getElementById("moose-equation-89684e68-1d66-46cd-ad0b-92d32ccefbcd");katex.render("\\psi = 0.5 c \\bs{u} \\cdot \\bs{u}", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\normal":"\\bs{n}","\\divergence":"\\nabla \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\diff":"\\text{ d}#1","\\total":"\\text{total}","\\internal":"\\text{internal}","\\external":"\\text{external}","\\elastic":"\\text{elastic}","\\fracture":"\\text{fracture}","\\critical":"\\text{critical}","\\activeenergy":"{\\left< A \\right>}","\\inactiveenergy":"{\\left< I \\right>}","\\Gc":"{\\mathcal{G}_c}","\\strain":"\\bs{\\varepsilon}","\\stress":"\\bs{\\sigma}","\\xstress":"\\widetilde{\\stress}","\\macaulay":"\\left<#1\\right>","\\body":"\\Omega","\\bodyboundary":"{\\partial\\body}","\\grad":"\\bs{\\nabla}"}});</script></span>.</li><li class="collection-item"><a href="../../source/materials/TissueElasticPK1Stress.html">TissueElasticPK1Stress</a>Compute stress using the Mooney-Rivlin hyperelastic model</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="../../source/materials/HeatConductionMaterial.html">ADHeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="../../source/materials/AnisoHeatConductionMaterial.html">AnisoHeatConductionMaterial</a></li><li class="collection-item"><a href="../../source/materials/ElectricalConductivity.html">ElectricalConductivity</a>Calculates resistivity and electrical conductivity as a function of temperature, using copper for parameter defaults.</li><li class="collection-item"><a href="../../source/materials/GapConductance.html">GapConductance</a></li><li class="collection-item"><a href="../../source/materials/GapConductanceConstant.html">GapConductanceConstant</a>Material to compute a constant, prescribed gap conductance</li><li class="collection-item"><a href="../../source/materials/HeatConductionMaterial.html">HeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="../../source/materials/SemiconductorLinearConductivity.html">SemiconductorLinearConductivity</a>Calculates electrical conductivity of a semiconductor from temperature</li><li class="collection-item"><a href="../../source/materials/SideSetHeatTransferMaterial.html">SideSetHeatTransferMaterial</a>This material constructs the necessary coefficients and properties for SideSetHeatTransferKernel.</li><li class="collection-header">Tensor Mechanics App</li><li class="collection-item"><a href="../../source/materials/ADComputeAxisymmetricRZFiniteStrain.html">ADComputeAxisymmetricRZFiniteStrain</a>Compute a strain increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="../../source/materials/ADComputeAxisymmetricRZIncrementalStrain.html">ADComputeAxisymmetricRZIncrementalStrain</a>Compute a strain increment and rotation increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="../../source/materials/ADComputeAxisymmetricRZSmallStrain.html">ADComputeAxisymmetricRZSmallStrain</a>Compute a small strain in an Axisymmetric geometry</li><li class="collection-item"><a href="../../source/materials/ADComputeDilatationThermalExpansionFunctionEigenstrain.html">ADComputeDilatationThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the total dilatation as a function of temperature</li><li class="collection-item"><a href="../../source/materials/ADComputeEigenstrain.html">ADComputeEigenstrain</a>Computes a constant Eigenstrain</li><li class="collection-item"><a href="../../source/materials/ComputeElasticityTensor.html">ADComputeElasticityTensor</a>Compute an elasticity tensor.</li><li class="collection-item"><a href="../../source/materials/ADComputeFiniteShellStrain.html">ADComputeFiniteShellStrain</a>Compute a large strain increment for the shell.</li><li class="collection-item"><a href="../../source/materials/ADComputeFiniteStrain.html">ADComputeFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="../../source/materials/ADComputeFiniteStrainElasticStress.html">ADComputeFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="../../source/materials/ADComputeGreenLagrangeStrain.html">ADComputeGreenLagrangeStrain</a>Compute a Green-Lagrange strain.</li><li class="collection-item"><a href="../../source/materials/ADComputeIncrementalShellStrain.html">ADComputeIncrementalShellStrain</a>Compute a small strain increment for the shell.</li><li class="collection-item"><a href="../../source/materials/ADComputeIncrementalSmallStrain.html">ADComputeIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="../../source/materials/ADComputeInstantaneousThermalExpansionFunctionEigenstrain.html">ADComputeInstantaneousThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the instantaneous thermal expansion as a function of temperature</li><li class="collection-item"><a href="../../source/materials/ComputeIsotropicElasticityTensor.html">ADComputeIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="../../source/materials/ADComputeIsotropicElasticityTensorShell.html">ADComputeIsotropicElasticityTensorShell</a>Compute a plane stress isotropic elasticity tensor.</li><li class="collection-item"><a href="../../source/materials/ADComputeLinearElasticStress.html">ADComputeLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="../../source/materials/ADComputeMeanThermalExpansionFunctionEigenstrain.html">ADComputeMeanThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the mean thermal expansion as a function of temperature</li><li class="collection-item"><a href="../../source/materials/ADComputeMultipleInelasticStress.html">ADComputeMultipleInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process.  Combinations of creep models and plastic models may be used.</li><li class="collection-item"><a href="../../source/materials/ADComputeMultiplePorousInelasticStress.html">ADComputeMultiplePorousInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process. A porosity material property is defined and is calculated from the trace of inelastic strain increment.</li><li class="collection-item"><a href="../../source/materials/ADComputePlaneFiniteStrain.html">ADComputePlaneFiniteStrain</a>Compute strain increment and rotation increment for finite strain under 2D planar assumptions.</li><li class="collection-item"><a href="../../source/materials/ADComputePlaneIncrementalStrain.html">ADComputePlaneIncrementalStrain</a>Compute strain increment for small strain under 2D planar assumptions.</li><li class="collection-item"><a href="../../source/materials/ADComputePlaneSmallStrain.html">ADComputePlaneSmallStrain</a>Compute a small strain under generalized plane strain assumptions where the out of plane strain is generally nonzero.</li><li class="collection-item"><a href="../../source/materials/ADComputeRSphericalFiniteStrain.html">ADComputeRSphericalFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="../../source/materials/ADComputeRSphericalIncrementalStrain.html">ADComputeRSphericalIncrementalStrain</a>Compute a strain increment for incremental strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="../../source/materials/ADComputeRSphericalSmallStrain.html">ADComputeRSphericalSmallStrain</a>Compute a small strain 1D spherical symmetry case.</li><li class="collection-item"><a href="../../source/materials/ADComputeShellStress.html">ADComputeShellStress</a>Compute in-plane stress using elasticity for shell</li><li class="collection-item"><a href="../../source/materials/ADComputeSmallStrain.html">ADComputeSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="../../source/materials/ADComputeStrainIncrementBasedStress.html">ADComputeStrainIncrementBasedStress</a>Compute stress after subtracting inelastic strain increments</li><li class="collection-item"><a href="../../source/materials/ADComputeThermalExpansionEigenstrain.html">ADComputeThermalExpansionEigenstrain</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="../../source/materials/ADComputeVariableIsotropicElasticityTensor.html">ADComputeVariableIsotropicElasticityTensor</a>Compute an isotropic elasticity tensor for elastic constants that change as a function of material properties</li><li class="collection-item"><a href="../../source/materials/ADIsotropicPlasticityStressUpdate.html">ADIsotropicPlasticityStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity model.  This class is one of the basic radial return constitutive models, yet it can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="../../source/materials/ADPowerLawCreepStressUpdate.html">ADPowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model. This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="../../source/materials/RankTwoCartesianComponent.html">ADRankTwoCartesianComponent</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="../../source/materials/RankTwoCylindricalComponent.html">ADRankTwoCylindricalComponent</a>Compute components of a rank-2 tensor in a cylindrical coordinate system</li><li class="collection-item"><a href="../../source/materials/RankTwoDirectionalComponent.html">ADRankTwoDirectionalComponent</a>Compute a Direction scalar property of a RankTwoTensor</li><li class="collection-item"><a href="../../source/materials/RankTwoInvariant.html">ADRankTwoInvariant</a>Compute a invariant property of a RankTwoTensor</li><li class="collection-item"><a href="../../source/materials/ADViscoplasticityStressUpdate.html">ADViscoplasticityStressUpdate</a>This material computes the non-linear homogenized gauge stress in order to compute the viscoplastic responce due to creep in porous materials. This material must be used in conjunction with ADComputeMultiplePorousInelasticStress</li><li class="collection-item"><a href="../../source/materials/AbruptSoftening.html">AbruptSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="../../source/materials/CappedDruckerPragerCosseratStressUpdate.html">CappedDruckerPragerCosseratStressUpdate</a>Capped Drucker-Prager plasticity stress calculator for the Cosserat situation where the host medium (ie, the limit where all Cosserat effects are zero) is isotropic.  Note that the return-map flow rule uses an isotropic elasticity tensor built with the &#x27;host&#x27; properties defined by the user.</li><li class="collection-item"><a href="../../source/materials/CappedDruckerPragerStressUpdate.html">CappedDruckerPragerStressUpdate</a>Capped Drucker-Prager plasticity stress calculator</li><li class="collection-item"><a href="../../source/materials/CappedMohrCoulombCosseratStressUpdate.html">CappedMohrCoulombCosseratStressUpdate</a>Capped Mohr-Coulomb plasticity stress calculator for the Cosserat situation where the host medium (ie, the limit where all Cosserat effects are zero) is isotropic.  Note that the return-map flow rule uses an isotropic elasticity tensor built with the &#x27;host&#x27; properties defined by the user.</li><li class="collection-item"><a href="../../source/materials/CappedMohrCoulombStressUpdate.html">CappedMohrCoulombStressUpdate</a>Nonassociative, smoothed, Mohr-Coulomb plasticity capped with tensile (Rankine) and compressive caps, with hardening/softening</li><li class="collection-item"><a href="../../source/materials/CappedWeakInclinedPlaneStressUpdate.html">CappedWeakInclinedPlaneStressUpdate</a>Capped weak inclined plane plasticity stress calculator</li><li class="collection-item"><a href="../../source/materials/CappedWeakPlaneCosseratStressUpdate.html">CappedWeakPlaneCosseratStressUpdate</a>Capped weak-plane plasticity Cosserat stress calculator</li><li class="collection-item"><a href="../../source/materials/CappedWeakPlaneStressUpdate.html">CappedWeakPlaneStressUpdate</a>Capped weak-plane plasticity stress calculator</li><li class="collection-item"><a href="../../source/materials/CombinedScalarDamage.html">CombinedScalarDamage</a>Scalar damage model which is computed as a function of multiple scalar damage models</li><li class="collection-item"><a href="../../source/materials/CompositeEigenstrain.html">CompositeEigenstrain</a>Assemble an Eigenstrain tensor from multiple tensor contributions weighted by material properties</li><li class="collection-item"><a href="../../source/materials/CompositeElasticityTensor.html">CompositeElasticityTensor</a>Assemble an elasticity tensor from multiple tensor contributions weighted by material properties</li><li class="collection-item"><a href="../../source/materials/ComputeAxisymmetric1DFiniteStrain.html">ComputeAxisymmetric1DFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in an axisymmetric 1D problem</li><li class="collection-item"><a href="../../source/materials/ComputeAxisymmetric1DIncrementalStrain.html">ComputeAxisymmetric1DIncrementalStrain</a>Compute strain increment for small strains in an axisymmetric 1D problem</li><li class="collection-item"><a href="../../source/materials/ComputeAxisymmetric1DSmallStrain.html">ComputeAxisymmetric1DSmallStrain</a>Compute a small strain in an Axisymmetric 1D problem</li><li class="collection-item"><a href="../../source/materials/ComputeAxisymmetricRZFiniteStrain.html">ComputeAxisymmetricRZFiniteStrain</a>Compute a strain increment for finite strains under axisymmetric assumptions.</li><li class="collection-item"><a href="../../source/materials/ComputeAxisymmetricRZIncrementalStrain.html">ComputeAxisymmetricRZIncrementalStrain</a>Compute a strain increment and rotation increment for small strains under axisymmetric assumptions.</li><li class="collection-item"><a href="../../source/materials/ComputeAxisymmetricRZSmallStrain.html">ComputeAxisymmetricRZSmallStrain</a>Compute a small strain in an Axisymmetric geometry</li><li class="collection-item"><a href="../../source/materials/ComputeBeamResultants.html">ComputeBeamResultants</a>Compute forces and moments using elasticity</li><li class="collection-item"><a href="../../source/materials/ComputeConcentrationDependentElasticityTensor.html">ComputeConcentrationDependentElasticityTensor</a>Compute concentration dependent elasticity tensor.</li><li class="collection-item"><a href="../../source/materials/ComputeCosseratElasticityTensor.html">ComputeCosseratElasticityTensor</a>Compute Cosserat elasticity and flexural bending rigidity tensors</li><li class="collection-item"><a href="../../source/materials/ComputeCosseratIncrementalSmallStrain.html">ComputeCosseratIncrementalSmallStrain</a>Compute incremental small Cosserat strains</li><li class="collection-item"><a href="../../source/materials/ComputeCosseratLinearElasticStress.html">ComputeCosseratLinearElasticStress</a>Compute Cosserat stress and couple-stress elasticity for small strains</li><li class="collection-item"><a href="../../source/materials/ComputeCosseratSmallStrain.html">ComputeCosseratSmallStrain</a>Compute small Cosserat strains</li><li class="collection-item"><a href="../../source/materials/ComputeCrackedStress.html">ComputeCrackedStress</a>Computes energy and modifies the stress for phase field fracture</li><li class="collection-item"><a href="../../source/materials/ComputeDamageStress.html">ComputeDamageStress</a>Compute stress for damaged elastic materials in conjunction with a damage model.</li><li class="collection-item"><a href="../../source/materials/ComputeDeformGradBasedStress.html">ComputeDeformGradBasedStress</a>Computes stress based on Lagrangian strain</li><li class="collection-item"><a href="../../source/materials/ComputeDilatationThermalExpansionFunctionEigenstrain.html">ComputeDilatationThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the total dilatation as a function of temperature</li><li class="collection-item"><a href="../../source/materials/ComputeEigenstrain.html">ComputeEigenstrain</a>Computes a constant Eigenstrain</li><li class="collection-item"><a href="../../source/materials/ComputeEigenstrainBeamFromVariable.html">ComputeEigenstrainBeamFromVariable</a>Computes an eigenstrain from a set of variables</li><li class="collection-item"><a href="../../source/materials/ComputeEigenstrainFromInitialStress.html">ComputeEigenstrainFromInitialStress</a>Computes an eigenstrain from an initial stress</li><li class="collection-item"><a href="../../source/materials/ComputeElasticityBeam.html">ComputeElasticityBeam</a>Computes the equivalent of the elasticity tensor for the beam element, which are vectors of material translational and flexural stiffness.</li><li class="collection-item"><a href="../../source/materials/ComputeElasticityTensor.html">ComputeElasticityTensor</a>Compute an elasticity tensor.</li><li class="collection-item"><a href="../../source/materials/ComputeElasticityTensorCP.html">ComputeElasticityTensorCP</a>Compute an elasticity tensor for crystal plasticity.</li><li class="collection-item"><a href="../../source/materials/ComputeExtraStressConstant.html">ComputeExtraStressConstant</a>Computes a constant extra stress that is added to the stress calculated by the constitutive model</li><li class="collection-item"><a href="../../source/materials/ComputeExtraStressVDWGas.html">ComputeExtraStressVDWGas</a>Computes a hydrostatic stress corresponding to the pressure of a van der Waals gas that is added as an extra_stress to the stress computed by the constitutive model</li><li class="collection-item"><a href="../../source/materials/ComputeFiniteBeamStrain.html">ComputeFiniteBeamStrain</a>Compute a rotation increment for finite rotations of the beam and computes the small/large strain increments in the current rotated configuration of the beam.</li><li class="collection-item"><a href="../../source/materials/ComputeFiniteStrain.html">ComputeFiniteStrain</a>Compute a strain increment and rotation increment for finite strains.</li><li class="collection-item"><a href="../../source/materials/ComputeFiniteStrainElasticStress.html">ComputeFiniteStrainElasticStress</a>Compute stress using elasticity for finite strains</li><li class="collection-item"><a href="../../source/materials/ComputeGlobalStrain.html">ComputeGlobalStrain</a>Material for storing the global strain values from the scalar variable</li><li class="collection-item"><a href="../../source/materials/ComputeIncrementalBeamStrain.html">ComputeIncrementalBeamStrain</a>Compute a infinitesimal/large strain increment for the beam.</li><li class="collection-item"><a href="../../source/materials/ComputeIncrementalSmallStrain.html">ComputeIncrementalSmallStrain</a>Compute a strain increment and rotation increment for small strains.</li><li class="collection-item"><a href="../../source/materials/ComputeInstantaneousThermalExpansionFunctionEigenstrain.html">ComputeInstantaneousThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the instantaneous thermal expansion as a function of temperature</li><li class="collection-item"><a href="../../source/materials/ComputeInterfaceStress.html">ComputeInterfaceStress</a>Stress in the plane of an interface defined by the gradient of an order parameter</li><li class="collection-item"><a href="../../source/materials/ComputeIsotropicElasticityTensor.html">ComputeIsotropicElasticityTensor</a>Compute a constant isotropic elasticity tensor.</li><li class="collection-item"><a href="../../source/materials/ComputeLayeredCosseratElasticityTensor.html">ComputeLayeredCosseratElasticityTensor</a>Computes Cosserat elasticity and flexural bending rigidity tensors relevant for simulations with layered materials.  The layering direction is assumed to be perpendicular to the &#x27;z&#x27; direction.</li><li class="collection-item"><a href="../../source/materials/ComputeLinearElasticPFFractureStress.html">ComputeLinearElasticPFFractureStress</a>Computes the stress and free energy derivatives for the phase field fracture model, with small strain</li><li class="collection-item"><a href="../../source/materials/ComputeLinearElasticStress.html">ComputeLinearElasticStress</a>Compute stress using elasticity for small strains</li><li class="collection-item"><a href="../../source/materials/ComputeLinearViscoelasticStress.html">ComputeLinearViscoelasticStress</a>Divides total strain into elastic + creep + eigenstrains</li><li class="collection-item"><a href="../../source/materials/ComputeMeanThermalExpansionFunctionEigenstrain.html">ComputeMeanThermalExpansionFunctionEigenstrain</a>Computes eigenstrain due to thermal expansion using a function that describes the mean thermal expansion as a function of temperature</li><li class="collection-item"><a href="../../source/materials/ComputeMultiPlasticityStress.html">ComputeMultiPlasticityStress</a>Material for multi-surface finite-strain plasticity</li><li class="collection-item"><a href="../../source/materials/ComputeMultipleInelasticCosseratStress.html">ComputeMultipleInelasticCosseratStress</a>Compute state (stress and other quantities such as plastic strains and internal parameters) using an iterative process, as well as Cosserat versions of these quantities.  Only elasticity is currently implemented for the Cosserat versions.Combinations of creep models and plastic models may be used</li><li class="collection-item"><a href="../../source/materials/ComputeMultipleInelasticStress.html">ComputeMultipleInelasticStress</a>Compute state (stress and internal parameters such as plastic strains and internal parameters) using an iterative process.  Combinations of creep models and plastic models may be used.</li><li class="collection-item"><a href="../../source/materials/ComputePlaneFiniteStrain.html">ComputePlaneFiniteStrain</a>Compute strain increment and rotation increment for finite strain under 2D planar assumptions.</li><li class="collection-item"><a href="../../source/materials/ComputePlaneIncrementalStrain.html">ComputePlaneIncrementalStrain</a>Compute strain increment for small strain under 2D planar assumptions.</li><li class="collection-item"><a href="../../source/materials/ComputePlaneSmallStrain.html">ComputePlaneSmallStrain</a>Compute a small strain under generalized plane strain assumptions where the out of plane strain is generally nonzero.</li><li class="collection-item"><a href="../../source/materials/ComputePlasticHeatEnergy.html">ComputePlasticHeatEnergy</a>Plastic heat energy density = stress * plastic_strain_rate</li><li class="collection-item"><a href="../../source/materials/ComputeRSphericalFiniteStrain.html">ComputeRSphericalFiniteStrain</a>Compute a strain increment and rotation increment for finite strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="../../source/materials/ComputeRSphericalIncrementalStrain.html">ComputeRSphericalIncrementalStrain</a>Compute a strain increment for incremental strains in 1D spherical symmetry problems.</li><li class="collection-item"><a href="../../source/materials/ComputeRSphericalSmallStrain.html">ComputeRSphericalSmallStrain</a>Compute a small strain 1D spherical symmetry case.</li><li class="collection-item"><a href="../../source/materials/ComputeReducedOrderEigenstrain.html">ComputeReducedOrderEigenstrain</a>accepts eigenstrains and computes a reduced order eigenstrain for consistency in the order of strain and eigenstrains.</li><li class="collection-item"><a href="../../source/materials/ComputeSmallStrain.html">ComputeSmallStrain</a>Compute a small strain.</li><li class="collection-item"><a href="../../source/materials/ComputeSmearedCrackingStress.html">ComputeSmearedCrackingStress</a>Compute stress using a fixed smeared cracking model</li><li class="collection-item"><a href="../../source/materials/ComputeStrainIncrementBasedStress.html">ComputeStrainIncrementBasedStress</a>Compute stress after subtracting inelastic strain increments</li><li class="collection-item"><a href="../../source/materials/ComputeSurfaceTensionKKS.html">ComputeSurfaceTensionKKS</a>Surface tension of an interface defined by the gradient of an order parameter</li><li class="collection-item"><a href="../../source/materials/ComputeThermalExpansionEigenstrain.html">ComputeThermalExpansionEigenstrain</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="../../source/materials/ComputeThermalExpansionEigenstrainBeam.html">ComputeThermalExpansionEigenstrainBeam</a>Computes eigenstrain due to thermal expansion with a constant coefficient</li><li class="collection-item"><a href="../../source/materials/ComputeVariableBaseEigenStrain.html">ComputeVariableBaseEigenStrain</a>Computes Eigenstrain based on material property tensor base</li><li class="collection-item"><a href="../../source/materials/ComputeVariableEigenstrain.html">ComputeVariableEigenstrain</a>Computes an Eigenstrain and its derivatives that is a function of multiple variables, where the prefactor is defined in a derivative material</li><li class="collection-item"><a href="../../source/materials/ComputeVariableIsotropicElasticityTensor.html">ComputeVariableIsotropicElasticityTensor</a>Compute an isotropic elasticity tensor for elastic constants that change as a function of material properties</li><li class="collection-item"><a href="../../source/materials/ComputeVolumetricDeformGrad.html">ComputeVolumetricDeformGrad</a>Computes volumetric deformation gradient and adjusts the total deformation gradient</li><li class="collection-item"><a href="../../source/materials/ComputeVolumetricEigenstrain.html">ComputeVolumetricEigenstrain</a>Computes an eigenstrain that is defined by a set of scalar material properties that summed together define the volumetric change.  This also computes the derivatives of that eigenstrain with respect to a supplied set of variable dependencies.</li><li class="collection-item"><a href="../../source/materials/EshelbyTensor.html">EshelbyTensor</a>Computes the Eshelby tensor as a function of strain energy density and the first Piola-Kirchoff stress</li><li class="collection-item"><a href="../../source/materials/ExponentialSoftening.html">ExponentialSoftening</a>Softening model with an exponential softening response upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="../../source/materials/FiniteStrainCPSlipRateRes.html">FiniteStrainCPSlipRateRes</a>Crystal Plasticity base class: FCC system with power law flow rule implemented</li><li class="collection-item"><a href="../../source/materials/FiniteStrainCrystalPlasticity.html">FiniteStrainCrystalPlasticity</a>Crystal Plasticity base class: FCC system with power law flow rule implemented</li><li class="collection-item"><a href="../../source/materials/FiniteStrainHyperElasticViscoPlastic.html">FiniteStrainHyperElasticViscoPlastic</a>Material class for hyper-elastic viscoplatic flow: Can handle multiple flow models defined by flowratemodel type user objects</li><li class="collection-item"><a href="../../source/materials/FiniteStrainPlasticMaterial.html">FiniteStrainPlasticMaterial</a>Associative J2 plasticity with isotropic hardening.</li><li class="collection-item"><a href="../../source/materials/FiniteStrainUObasedCP.html">FiniteStrainUObasedCP</a>UserObject based Crystal Plasticity system.</li><li class="collection-item"><a href="../../source/materials/FluxBasedStrainIncrement.html">FluxBasedStrainIncrement</a>Compute strain increment based on flux</li><li class="collection-item"><a href="../../source/materials/GBRelaxationStrainIncrement.html">GBRelaxationStrainIncrement</a>Compute strain increment based on lattice relaxation at GB</li><li class="collection-item"><a href="../../source/materials/GeneralizedKelvinVoigtModel.html">GeneralizedKelvinVoigtModel</a>Generalized Kelvin-Voigt model composed of a serial assembly of unit Kelvin-Voigt modules</li><li class="collection-item"><a href="../../source/materials/GeneralizedMaxwellModel.html">GeneralizedMaxwellModel</a>Generalized Maxwell model composed of a parallel assembly of unit Maxwell modules</li><li class="collection-item"><a href="../../source/materials/HyperElasticPhaseFieldIsoDamage.html">HyperElasticPhaseFieldIsoDamage</a>Computes damaged stress and energy in the intermediate configuration assuming isotropy</li><li class="collection-item"><a href="../../source/materials/HyperbolicViscoplasticityStressUpdate.html">HyperbolicViscoplasticityStressUpdate</a>This class uses the discrete material for a hyperbolic sine viscoplasticity model in which the effective plastic strain is solved for using a creep approach.</li><li class="collection-item"><a href="../../source/materials/InclusionProperties.html">InclusionProperties</a></li><li class="collection-item"><a href="../../source/materials/IsotropicPlasticityStressUpdate.html">IsotropicPlasticityStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity model.  This class is one of the basic radial return constitutive models, yet it can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="../../source/materials/IsotropicPowerLawHardeningStressUpdate.html">IsotropicPowerLawHardeningStressUpdate</a>This class uses the discrete material in a radial return isotropic plasticity power law hardening model, solving for the yield stress as the intersection of the power law relation curve and Hooke&#x27;s law.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="../../source/materials/LinearElasticTruss.html">LinearElasticTruss</a>Computes the linear elastic strain for a truss element</li><li class="collection-item"><a href="../../source/materials/LinearViscoelasticStressUpdate.html">LinearViscoelasticStressUpdate</a>Calculates an admissible state (stress that lies on or within the yield surface, plastic strains, internal parameters, etc).  This class is intended to be a parent class for classes with specific constitutive models.</li><li class="collection-item"><a href="../../source/materials/MultiPhaseStressMaterial.html">MultiPhaseStressMaterial</a>Compute a global stress form multiple phase stresses</li><li class="collection-item"><a href="../../source/materials/PlasticTruss.html">PlasticTruss</a>Computes the stress and strain for a truss element with plastic behavior defined by either linear hardening or a user-defined hardening function.</li><li class="collection-item"><a href="../../source/materials/PowerLawCreepStressUpdate.html">PowerLawCreepStressUpdate</a>This class uses the stress update material in a radial return isotropic power law creep model.  This class can be used in conjunction with other creep and plasticity materials for more complex simulations.</li><li class="collection-item"><a href="../../source/materials/PowerLawSoftening.html">PowerLawSoftening</a>Softening model with an abrupt stress release upon cracking. This class is intended to be used with ComputeSmearedCrackingStress.</li><li class="collection-item"><a href="../../source/materials/RankTwoCartesianComponent.html">RankTwoCartesianComponent</a>Access a component of a RankTwoTensor</li><li class="collection-item"><a href="../../source/materials/RankTwoCylindricalComponent.html">RankTwoCylindricalComponent</a>Compute components of a rank-2 tensor in a cylindrical coordinate system</li><li class="collection-item"><a href="../../source/materials/RankTwoDirectionalComponent.html">RankTwoDirectionalComponent</a>Compute a Direction scalar property of a RankTwoTensor</li><li class="collection-item"><a href="../../source/materials/RankTwoInvariant.html">RankTwoInvariant</a>Compute a invariant property of a RankTwoTensor</li><li class="collection-item"><a href="../../source/materials/czm/SalehaniIrani3DCTraction.html">SalehaniIrani3DCTraction</a>3D Coupled (3DC) cohesive law of Salehani and Irani with no damage</li><li class="collection-item"><a href="../../source/materials/ScalarMaterialDamage.html">ScalarMaterialDamage</a>Scalar damage model for which the damage is prescribed by another material</li><li class="collection-item"><a href="../../source/materials/StrainEnergyDensity.html">StrainEnergyDensity</a>Computes the strain energy density using a combination of the elastic and inelastic components of the strain increment, which is a valid assumption for monotonic behavior.</li><li class="collection-item"><a href="../../source/materials/StressBasedChemicalPotential.html">StressBasedChemicalPotential</a>Chemical potential from stress</li><li class="collection-item"><a href="../../source/materials/SumTensorIncrements.html">SumTensorIncrements</a>Compute tensor property by summing tensor increments</li><li class="collection-item"><a href="../../source/materials/TemperatureDependentHardeningStressUpdate.html">TemperatureDependentHardeningStressUpdate</a>Computes the stress as a function of temperature and plastic strain from user-supplied hardening functions. This class can be used in conjunction with other creep and plasticity materials for more complex simulations</li><li class="collection-item"><a href="../../source/materials/TensileStressUpdate.html">TensileStressUpdate</a>Associative, smoothed, tensile (Rankine) plasticity with hardening/softening</li><li class="collection-item"><a href="../../source/materials/ThermalFractureIntegral.html">ThermalFractureIntegral</a>Calculates summation of the derivative of the eigenstrains with respect to temperature.</li><li class="collection-item"><a href="../../source/materials/TwoPhaseStressMaterial.html">TwoPhaseStressMaterial</a>Compute a global stress in a two phase model</li><li class="collection-item"><a href="../../source/materials/VolumeDeformGradCorrectedStress.html">VolumeDeformGradCorrectedStress</a>Transforms stress with volumetric term from previous configuration to this configuration</li></ul></section><section class="scrollspy" id="39eaeffc-efc2-4308-a1f3-bbeb6241a37e" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddMaterialAction.html">AddMaterialAction</a></li></ul></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#67ab34d9-3e49-4818-ab9e-969e7852859d" class="tooltipped" data-position="left" data-tooltip="Producing / Computing Properties">Producing / Computing Properties</a></li><li><a href="#e3fbaf2c-fe4e-4e61-b1c3-16f4ddf8c0e0" class="tooltipped" data-position="left" data-tooltip="Consuming Properties">Consuming Properties</a></li><li><a href="#08ed571d-cc8d-46cd-9016-57df9894006a" class="tooltipped" data-position="left" data-tooltip="Property Names">Property Names</a></li><li><a href="#1fe7e094-bf57-4255-86a2-c74b3713612c" class="tooltipped" data-position="left" data-tooltip="Default Material Properties">Default Material Properties</a></li><li><a href="#3a356c8d-1523-497e-a293-8cca379fd8bd" class="tooltipped" data-position="left" data-tooltip="Stateful Material Properties">Stateful Material Properties</a></li><li><a href="#a01f7707-3d52-4072-9e28-326c48ee89d8" class="tooltipped" data-position="left" data-tooltip="Material Property Output">Material Property Output</a></li><li><a href="#73acb856-e794-4fa3-bd5b-f58e3c70993e" class="tooltipped" data-position="left" data-tooltip="Advanced Topics">Advanced Topics</a></li><li><a href="#f4ece308-4849-49c0-b404-54d8421ffb87" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#39eaeffc-efc2-4308-a1f3-bbeb6241a37e" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>